const { db } = require('../../config/firebaseAdmin');

class Issue {
    static collection = db.collection('issues'); // New collection name

    static async create(issueData) {
        const now = new Date().toISOString();

        // Basic sanitization
        const cleanData = {};
        for (const [key, value] of Object.entries(issueData)) {
            if (value !== undefined) {
                cleanData[key] = value;
            }
        }

        const data = {
            ...cleanData,
            status: cleanData.status || 'To Do',
            type: cleanData.type || 'Task', // Story, Bug, Task
            priority: cleanData.priority || 'Medium',
            storyPoints: cleanData.storyPoints || 0,
            reporterId: cleanData.reporterId, // Who created it
            assigneeId: cleanData.assigneeId || null,
            projectId: cleanData.projectId,
            sprintId: cleanData.sprintId || null, // Null = Backlog
            dueDate: cleanData.dueDate || null,
            description: cleanData.description || '', // Added description
            // Time Tracking
            originalEstimate: cleanData.originalEstimate || 0, // Minutes
            remainingEstimate: cleanData.remainingEstimate || 0, // Minutes
            timeSpent: cleanData.timeSpent || 0, // Minutes
            comments: [], // Array of { id, text, userId, createdAt }
            history: [], // Activity log
            createdAt: now,
            updatedAt: now
        };

        // Note: issueId (e.g. PROJ-123) should be generated by controller in a transaction
        // But if passed, we use it.
        if (cleanData.issueId) {
            data.issueId = cleanData.issueId;
        }

        const res = await Issue.collection.add(data);
        return { id: res.id, ...data };
    }

    static async findAll(query = {}) {
        let localQuery = Issue.collection;
        if (query.where) {
            for (const [key, value] of Object.entries(query.where)) {
                localQuery = localQuery.where(key, '==', value);
            }
        }
        const snapshot = await localQuery.get();
        return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    }

    static async findByPk(id) {
        if (!id) return null;
        const doc = await Issue.collection.doc(id).get();
        if (!doc.exists) return null;
        return { id: doc.id, ...doc.data() };
    }

    static async update(id, updates) {
        await Issue.collection.doc(id).update({
            ...updates,
            updatedAt: new Date().toISOString()
        });
        return { id, ...updates };
    }

    static async destroy(query) {
        if (query.where && query.where.id) {
            await Issue.collection.doc(query.where.id).delete();
            return 1;
        }
        return 0;
    }
}

module.exports = Issue;
